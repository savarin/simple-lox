"""
The parser.py module is responsible for converting a sequence of tokens, provided by the scanner.py
module, into an abstract syntax tree (AST). This AST represents the structure and syntax of the
programming language being interpreted. The parser handles constructs like variable declarations,
function definitions, and control flow statements.
"""

from typing import List, Tuple

from expr import Operator
from scanner import TokenType
import expr
import scanner
import statem


def parse(tokens: List[scanner.Token]) -> List[statem.Statem]:
    """
    Parses a list of tokens into an abstract syntax tree (AST).

    Args:
        tokens (List[scanner.Token]): A list of tokens generated by the scanner.

    Returns:
        List[statem.Statem]: A list of statement objects representing the AST.
    """
    statements: List[statem.Statem] = []
    counter: int = 0

    while tokens[counter].token_type != TokenType.EOF:
        individual_statement, counter = statement(tokens, counter)
        statements.append(individual_statement)

    return statements


def expect(
    tokens: List[scanner.Token], counter: int, token_type: TokenType
) -> Tuple[scanner.Token, int]:
    """
    Verifies that the next token in the list matches the expected token type.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.
        token_type (TokenType): The expected type of the next token.

    Returns:
        Tuple[scanner.Token, int]: The matched token and the new position in the token list.

    Raises:
        Exception: If the token does not match the expected type.
    """
    token = tokens[counter]
    counter += 1

    if token.token_type == token_type:
        return token, counter

    raise ValueError(
        f"Expected token type '{token_type}' but found '{token.token_type}' at position {counter}. Token: {token}"
    )


def statement(tokens: List[scanner.Token], counter: int) -> Tuple[statem.Statem, int]:
    """
    Parses a single statement from the token list.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.

    Returns:
        Tuple[statem.Statem, int]: A tuple containing the parsed statement and the new position
        in the token list.

    Raises:
        Exception: If the statement type is not recognized.
    """
    match tokens[counter].token_type:
        case TokenType.BRACE_LEFT:
            return block(tokens, counter)

        case TokenType.FUNC:
            return function(tokens, counter)

        case TokenType.IF:
            return if_statement(tokens, counter)

        case TokenType.VAR:
            return variable(tokens, counter)

        case TokenType.RETURN:
            return return_statement(tokens, counter)

        case TokenType.NAME | TokenType.INTEGER:
            return expression_statement(tokens, counter)

        case _:
            raise SyntaxError(
                f"Unhandled token type: '{tokens[counter].token_type}' at position {counter}. Token: {tokens[counter]}"
            )


def block(tokens: List[scanner.Token], counter: int) -> Tuple[statem.Statem, int]:
    """
    Parses a block of statements enclosed in braces from the token list.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.

    Returns:
        Tuple[statem.Statem, int]: A tuple containing the parsed block of statements and the new
        position in the token list.
    """
    # { statements }
    statements: List[statem.Statem] = []

    _, counter = expect(tokens, counter, TokenType.BRACE_LEFT)

    while tokens[counter].token_type != TokenType.BRACE_RIGHT:
        individual_statement, counter = statement(tokens, counter)
        statements.append(individual_statement)

    _, counter = expect(tokens, counter, TokenType.BRACE_RIGHT)

    return statem.Block(statements), counter


def function(tokens: List[scanner.Token], counter: int) -> Tuple[statem.Statem, int]:
    """
    Parses a function definition from the token list.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.

    Returns:
        Tuple[statem.Statem, int]: A tuple containing the parsed function definition and the new
        position in the token list.
    """
    # func name ( parameters ) { body }
    _, counter = expect(tokens, counter, TokenType.FUNC)
    name, counter = expect(tokens, counter, TokenType.NAME)
    _, counter = expect(tokens, counter, TokenType.PAREN_LEFT)

    parameters: List[expr.Name] = []

    while tokens[counter].token_type != TokenType.PAREN_RIGHT:
        parameter, counter = expect(tokens, counter, TokenType.NAME)
        parameters.append(expr.Name(parameter.value))

        if tokens[counter].token_type == TokenType.COMMA:
            _, counter = expect(tokens, counter, TokenType.COMMA)

    _, counter = expect(tokens, counter, TokenType.PAREN_RIGHT)
    body, counter = block(tokens, counter)

    assert isinstance(body, statem.Block)
    return statem.Function(expr.Name(name.value), parameters, body), counter


def if_statement(
    tokens: List[scanner.Token],
    counter: int,
) -> Tuple[statem.Statem, int]:
    """
    Parses an if statement from the token list, including optional else branch.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.

    Returns:
        Tuple[statem.Statem, int]: A tuple containing the parsed if statement and the new
        position in the token list.
    """
    # if ( condition ) { then_branch } [ else_branch ]
    _, counter = expect(tokens, counter, TokenType.IF)
    _, counter = expect(tokens, counter, TokenType.PAREN_LEFT)
    condition, counter = expression(tokens, counter)
    _, counter = expect(tokens, counter, TokenType.PAREN_RIGHT)
    then_branch, counter = block(tokens, counter)

    else_branch = None

    if tokens[counter].token_type == TokenType.ELSE:
        _, counter = expect(tokens, counter, TokenType.ELSE)
        else_branch, counter = block(tokens, counter)

    assert isinstance(then_branch, statem.Block)
    assert isinstance(else_branch, statem.Block) or else_branch is None
    return statem.If(condition, then_branch, else_branch), counter


def variable(tokens: List[scanner.Token], counter: int) -> Tuple[statem.Statem, int]:
    """
    Parses a variable declaration statement from the token list.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.

    Returns:
        Tuple[statem.Statem, int]: A tuple containing the parsed variable statement and the new
        position in the token list.
    """
    # var name initializer ;
    _, counter = expect(tokens, counter, TokenType.VAR)
    name, counter = expect(tokens, counter, TokenType.NAME)
    _, counter = expect(tokens, counter, TokenType.EQUAL)
    initializer, counter = expect(tokens, counter, TokenType.INTEGER)
    _, counter = expect(tokens, counter, TokenType.SEMICOLON)

    return (
        statem.Variable(expr.Name(name.value), expr.Integer(initializer.value)),
        counter,
    )


def return_statement(
    tokens: List[scanner.Token],
    counter: int,
) -> Tuple[statem.Statem, int]:
    """
    Parses a return statement from the token list.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.

    Returns:
        Tuple[statem.Statem, int]: A tuple containing the parsed return statement and the new
        position in the token list.
    """
    # return expression ;
    _, counter = expect(tokens, counter, TokenType.RETURN)
    value, counter = expression(tokens, counter)
    _, counter = expect(tokens, counter, TokenType.SEMICOLON)

    return statem.Return(value), counter


def expression_statement(
    # expression ;
    tokens: List[scanner.Token],
    counter: int,
) -> Tuple[statem.Statem, int]:
    """
    Parses an expression statement from the token list. Expression statements are expressions
    followed by a semicolon.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.

    Returns:
        Tuple[statem.Statem, int]: A tuple containing the parsed expression statement and the new
        position in the token list.
    """
    value, counter = expression(tokens, counter)
    _, counter = expect(tokens, counter, TokenType.SEMICOLON)

    return statem.Expression(value), counter


def expression(tokens: List[scanner.Token], counter: int) -> Tuple[expr.Expr, int]:
    """
    Parses a general expression from the token list, including relational, numeric, and other
    types of expressions.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.

    Returns:
        Tuple[expr.Expr, int]: The parsed expression and the new position in the token list.
    """
    return relational(tokens, counter)


def relational(tokens: List[scanner.Token], counter: int) -> Tuple[expr.Expr, int]:
    """
    Parses a relational expression, which includes operators like '=', '>', '<'.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.

    Returns:
        Tuple[expr.Expr, int]: The parsed relational expression and the new position in the
        token list.
    """
    # left = right
    left, counter = term(tokens, counter)

    while True:
        if tokens[counter].token_type not in [
            TokenType.EQUAL,
            TokenType.GREATER,
            TokenType.LESS,
        ]:
            break

        operator = Operator(tokens[counter].value)
        counter += 1

        right, counter = term(tokens, counter)
        left = expr.Relational(operator, left, right)

    return left, counter


def term(tokens: List[scanner.Token], counter: int) -> Tuple[expr.Expr, int]:
    """
    Parses a term in an expression, dealing with addition and subtraction operations.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.

    Returns:
        Tuple[expr.Expr, int]: The parsed term and the new position in the token list.
    """
    # left + right
    left, counter = factor(tokens, counter)

    while True:
        if tokens[counter].token_type not in [TokenType.PLUS, TokenType.MINUS]:
            break

        operator = Operator(tokens[counter].value)
        counter += 1

        right, counter = factor(tokens, counter)
        left = expr.Numeric(operator, left, right)

    return left, counter


def factor(tokens: List[scanner.Token], counter: int) -> Tuple[expr.Expr, int]:
    """
    Parses a factor in a term, related to multiplication and division operations.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.

    Returns:
        Tuple[expr.Expr, int]: The parsed factor and the new position in the token list.
    """
    # left * right
    left, counter = call(tokens, counter)

    while True:
        if tokens[counter].token_type != TokenType.TIMES:
            break

        operator = Operator(tokens[counter].value)
        counter += 1

        right, counter = call(tokens, counter)
        left = expr.Numeric(operator, left, right)

    return left, counter


def call(tokens: List[scanner.Token], counter: int) -> Tuple[expr.Expr, int]:
    """
    Parses a function call expression from the token list.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.

    Returns:
        Tuple[expr.Expr, int]: The parsed function call expression and the new position in the
        token list.
    """
    # name ( arguments )
    primary_expression, counter = primary(tokens, counter)

    if tokens[counter].token_type != TokenType.PAREN_LEFT:
        return primary_expression, counter

    _, counter = expect(tokens, counter, TokenType.PAREN_LEFT)

    arguments: List[expr.Expr] = []

    while tokens[counter].token_type != TokenType.PAREN_RIGHT:
        argument, counter = expression(tokens, counter)
        arguments.append(argument)

        if tokens[counter].token_type == TokenType.COMMA:
            _, counter = expect(tokens, counter, TokenType.COMMA)

    _, counter = expect(tokens, counter, TokenType.PAREN_RIGHT)

    assert isinstance(primary_expression, expr.Name)
    return expr.Call(primary_expression, arguments), counter


def primary(tokens: List[scanner.Token], counter: int) -> Tuple[expr.Expr, int]:
    """
    Parses a primary expression, including integers and names, from the token list.

    Args:
        tokens (List[scanner.Token]): The list of tokens.
        counter (int): The current position in the token list.

    Returns:
        Tuple[expr.Expr, int]: The parsed primary expression and the new position in the
        token list.

    Raises:
        Exception: If the primary expression type is not recognized.
    """
    match tokens[counter].token_type:
        case TokenType.INTEGER:
            token, counter = expect(tokens, counter, TokenType.INTEGER)
            return expr.Integer(token.value), counter

        case TokenType.NAME:
            token, counter = expect(tokens, counter, TokenType.NAME)
            return expr.Name(token.value), counter

        case _:
            raise SyntaxError(
                f"Unrecognized primary expression type for token '{tokens[counter].token_type}' at position {counter}. Token: {tokens[counter]}"
            )
